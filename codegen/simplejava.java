/* simplejava.java */
/* Generated By:JavaCC: Do not edit this line. simplejava.java */
public class simplejava implements simplejavaConstants {
        public static boolean emptyparams = true;
        public static boolean functioncall = false;

  static final public ASTOperatorExpression incrementstatement(ASTVariable variable) throws ParseException {
    jj_consume_token(ADD);
{if ("" != null) return new ASTOperatorExpression(new ASTVariableExpression(variable, variable.line()), new ASTIntegerLiteral(1, variable.line()), "+", variable.line());}
    throw new Error("Missing return statement in function");
  }

  static final public ASTOperatorExpression decrementstatement(ASTVariable variable) throws ParseException {
    jj_consume_token(MINUSMINUS);
{if ("" != null) return new ASTOperatorExpression(new ASTVariableExpression(variable, variable.line()), new ASTIntegerLiteral(1, variable.line()), "-", variable.line());}
    throw new Error("Missing return statement in function");
  }

  static final public ASTProgram program() throws ParseException {ASTClasses classes = new ASTClasses();
        ASTClass classdef = null;
        ASTFunctionDefinitions functiondefinitions = new ASTFunctionDefinitions();
        ASTFunctionDefinition funcdef = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CLASS:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      classdef = classdefinitions();
if (classes != null) classes.addElement(classdef);
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      funcdef = functionprototypeordefinition();
if (funcdef != null) functiondefinitions.addElement(funcdef);
    }
    jj_consume_token(0);
if (classdef != null)
                        {if ("" != null) return new ASTProgram(classes, functiondefinitions, classdef.line());}
                else
                        {if ("" != null) return new ASTProgram(classes, functiondefinitions, 0);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTFunctionDefinition functionprototypeordefinition() throws ParseException {Token type; Token name; ASTFormals formals = new ASTFormals(); ASTStatements body = new ASTStatements(); int line; ASTEmptyStatement semicolonchecker = null; ASTStatement returnedstatement = null;
    /* {System.out.println("I hit functiondefinition.");} */
            type = jj_consume_token(IDENTIFIER);
    name = jj_consume_token(IDENTIFIER);
    jj_consume_token(LEFT_PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      formals = formalparameterlist();
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      semicolonchecker = emptystatement();
      break;
      }
    case LEFT_BRACE:{
      jj_consume_token(LEFT_BRACE);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FOR:
        case IF:
        case WHILE:
        case DO:
        case RETURN:
        case SEMICOLON:
        case LEFT_BRACE:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
        returnedstatement = statement();
if (returnedstatement != null)body.addElement(returnedstatement);
      }
      jj_consume_token(RIGHT_BRACE);
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if (semicolonchecker != null) {
                {if ("" != null) return new ASTPrototype(type.image, name.image, formals, type.beginLine);}
        }else {
                {if ("" != null) return new ASTFunction(type.image, name.image, formals, body, type.beginLine);}
        }
    throw new Error("Missing return statement in function");
  }

//void functionendingafterparen() :
//{}
//{
        /* FUNCTION PROTOTYPE */
//	<SEMICOLON>
        /* FUNCTION DEFINITION */
//|	<LEFT_BRACE> ((statement())*) <RIGHT_BRACE>
//}
  static final public 
ASTFormals formalparameterlist() throws ParseException {ASTFormals formals = new ASTFormals(); ASTFormal formal = null;
    formal = formalparameter();
if (formal != null) {formals.addElement(formal);}
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      formal = formalparameter();
if (formal != null) {formals.addElement(formal);}
    }
{if ("" != null) return formals;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTFormal formalparameter() throws ParseException {Token type; Token name; int arraydimension = 0;
    type = jj_consume_token(IDENTIFIER);
    name = jj_consume_token(IDENTIFIER);
    arraydimension = variabledeclarations();
{if ("" != null) return new ASTFormal(type.image, name.image, arraydimension, type.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public int variabledeclarations() throws ParseException {int counter = 0;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_5;
      }
      jj_consume_token(LEFT_BRACKET);
      jj_consume_token(RIGHT_BRACKET);
counter++;
    }
{if ("" != null) return counter;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTInstanceVariableDefs variabledefinitions() throws ParseException {ASTInstanceVariableDefs variabledefs = new ASTInstanceVariableDefs(); ASTInstanceVariableDef variabledef = null; int counter = 0; Token type; Token name;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        break label_6;
      }
      type = jj_consume_token(IDENTIFIER);
      name = jj_consume_token(IDENTIFIER);
      counter = variabledeclarations();
      jj_consume_token(SEMICOLON);
if (counter == 0) {
                variabledef = new ASTInstanceVariableDef(type.image, name.image, type.beginLine);
                variabledefs.addElement(variabledef);
        } else {
                variabledef = new ASTInstanceVariableDef(type.image, name.image, counter, type.beginLine);
                variabledefs.addElement(variabledef);
        }
    }
{if ("" != null) return variabledefs;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionlist(String nameoffunction, Token variabletoken) throws ParseException {ASTExpression expressioncatch = null; ASTFunctionCallExpression funccall = new ASTFunctionCallExpression(nameoffunction, variabletoken.beginLine);
    /*public ASTFunctionCallStatement(String name, ASTExpression formal, int line) { */
            expressioncatch = expression();
if (expressioncatch != null) funccall.addElement(expressioncatch);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      expressioncatch = expression();
if (expressioncatch != null) funccall.addElement(expressioncatch);
    }
{if ("" != null) return funccall;}
    throw new Error("Missing return statement in function");
  }

//void statementlist() :
//{}
//{
//	statement()((statement())*)
//}
  static final public 
ASTVariable variable(ASTVariable passedinvar) throws ParseException {ASTVariable var = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFT_BRACKET:
    case PERIOD:{
      var = followsvariables(passedinvar);
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
{if ("" != null) return var;}
    throw new Error("Missing return statement in function");
  }

//void followsclassdefinitionstypes() :
//{}
//{
/* HAVE  TO CONSIDER THI CASE EVENTUALLY */
//	<LEFT_BRACKET> ((followsbracketsone())+) 
//}
  static final public 
ASTClass classdefinitions() throws ParseException {ASTClass astclass = null; Token stringt; ASTInstanceVariableDefs variabledefs = null;
    jj_consume_token(CLASS);
    stringt = jj_consume_token(IDENTIFIER);
    jj_consume_token(LEFT_BRACE);
    variabledefs = variabledefinitions();
    jj_consume_token(RIGHT_BRACE);
astclass = new ASTClass(stringt.image, variabledefs, stringt.beginLine);
{if ("" != null) return astclass;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement statement() throws ParseException {ASTForStatement forstatement; ASTDoWhileStatement dowhile; ASTStatement body; ASTAssignmentStatement assignstate; ASTVariable avariable = null; Token arrayvariabletoken = null; ASTExpression expression = null; int bracketcounter= 0; Token generaltoken; ASTVariable passedinvariable; ASTStatements returner = new ASTStatements();
ASTVariable bvariable = null; ASTBaseVariable basevariable = null; ASTIfStatement ifstatement;
ASTFunctionCallStatement funccallstate = null; ASTStatement params = null; ASTVariable variableforfollowsvariablenames = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DO:{
      /*{System.out.println("I HIT STATEMENT.");} */
              dowhile = dowhilestatement();
{if ("" != null) return dowhile;}
      break;
      }
    case RETURN:{
      generaltoken = jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TRUE:
      case FALSE:
      case NEW:
      case MINUS:
      case NOT:
      case LEFT_PARENTHESIS:
      case INTEGER_LITERAL:
      case IDENTIFIER:{
        expression = expression();
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
{if ("" != null) return new ASTReturnStatement(expression, generaltoken.beginLine);}
      break;
      }
    case WHILE:{
      generaltoken = jj_consume_token(WHILE);
      jj_consume_token(LEFT_PARENTHESIS);
      expression = expression();
      jj_consume_token(RIGHT_PARENTHESIS);
      body = statement();
{if ("" != null) return new ASTWhileStatement(expression, body, generaltoken.beginLine);}
      break;
      }
    case IF:{
      generaltoken = jj_consume_token(IF);
      ifstatement = ifstatement();
{if ("" != null) return ifstatement;}
      break;
      }
    case FOR:{
      forstatement = forstatement();
{if ("" != null) return forstatement;}
      break;
      }
    case LEFT_BRACE:{
      jj_consume_token(LEFT_BRACE);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FOR:
        case IF:
        case WHILE:
        case DO:
        case RETURN:
        case SEMICOLON:
        case LEFT_BRACE:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          break label_8;
        }
        body = statement();
if (body != null) returner.addElement(body);
      }
      jj_consume_token(RIGHT_BRACE);
{if ("" != null) return returner;}
      break;
      }
    case IDENTIFIER:{
      generaltoken = jj_consume_token(IDENTIFIER);
passedinvariable = new ASTBaseVariable(generaltoken.image, generaltoken.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        arrayvariabletoken = jj_consume_token(IDENTIFIER);
        bracketcounter = variabledeclarations();
avariable = new ASTBaseVariable(arrayvariabletoken.image, arrayvariabletoken.beginLine);
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        bvariable = variable(/* MAKE SURE TO MAKE CHANGES, was semicolon before but now is emptystatement because they mean the same thing */
                passedinvariable);
      }
if (bvariable != null) {variableforfollowsvariablenames = bvariable;} else if (avariable==null) {variableforfollowsvariablenames = passedinvariable;} else {variableforfollowsvariablenames = avariable;}
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_PARENTHESIS:
      case GETS:
      case ADD:
      case MINUSMINUS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case GETS:
        case ADD:
        case MINUSMINUS:{
          expression = followsvariablenames(variableforfollowsvariablenames);
          break;
          }
        case LEFT_PARENTHESIS:{
          params = functioncall(token);
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      emptystatement();
/*This handles the case: int a; */
                if (bracketcounter == 0 && arrayvariabletoken != null && bvariable == null && expression == null) {
                        //{System.out.println("0");}
                        {if ("" != null) return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, generaltoken.beginLine);}
                }
                /* This handles the case: a = 4 + 3; */
                if (!functioncall && bracketcounter == 0 && bvariable == null && expression != null && avariable == null) {
                        //{System.out.println("1");}

                        basevariable = new ASTBaseVariable(generaltoken.image, generaltoken.beginLine);
                        {if ("" != null) return new ASTAssignmentStatement(basevariable, expression, generaltoken.beginLine);}
                }
                /* This handles the case: a[3]=4+3; */
                if (bracketcounter != 0 && bvariable != null && expression != null && avariable == null) {
                                        //{System.out.println("2");}

                        basevariable = new ASTBaseVariable(generaltoken.image, generaltoken.beginLine);
                        {if ("" != null) return new ASTAssignmentStatement(basevariable, expression, generaltoken.beginLine);}
                }
                /* This handles the case: int x = 5 + 3;*/
                if (!functioncall && bracketcounter == 0 && bvariable == null && expression != null) {
                                        //{System.out.println("3");}

                        {if ("" != null) return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, expression,generaltoken.beginLine);}
                }
                /* This handles the case: int z[]; */
                if (bracketcounter != 0 && bvariable == null && expression == null) {
                                        //{System.out.println("4");}

                        {if ("" != null) return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, bracketcounter,generaltoken.beginLine);}
                }
                /* This handles the case: int z[3][] = 4 + 2; */
                if (!functioncall && bracketcounter != 0 && bvariable == null && expression != null) {
                                        //{System.out.println("5");}

                        {if ("" != null) return new ASTVariableDefStatement(generaltoken.image, arrayvariabletoken.image, bracketcounter, expression, generaltoken.beginLine);}
                }
                /* This handles the case: */
                if (!functioncall && arrayvariabletoken == null && bvariable != null && expression != null) {
                                        //{System.out.println("6");}

                        {if ("" != null) return new ASTAssignmentStatement(bvariable, expression, generaltoken.beginLine);}
                }
                if (!emptyparams && params!= null && passedinvariable != null && bvariable == null && avariable == null) {
                                        //{System.out.println("7");}
                        functioncall = false;
                        emptyparams = true;
                        /*funccallstate = new ASTFunctionCallStatement(generaltoken.image, expression, generaltoken.beginLine);*/
                        {if ("" != null) return params;}
                }
                if (emptyparams && passedinvariable != null && bvariable == null && avariable == null) {
                                        //{System.out.println("8");}
                        functioncall = false;
                        funccallstate = new ASTFunctionCallStatement(generaltoken.image, generaltoken.beginLine);
                        {if ("" != null) return funccallstate;}
                }

                if (expression == null || bvariable == null) {{if ("" != null) return null;}}
                else {{if ("" != null) return new ASTAssignmentStatement(avariable, expression, arrayvariabletoken.beginLine);}}
      break;
      }
    case SEMICOLON:{
      body = emptystatement();
{if ("" != null) return body;}
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTIfStatement ifstatement() throws ParseException {ASTExpression test; ASTStatement thenstatement; ASTStatement elsestatement = null; Token linenumbercatcher;
    linenumbercatcher = jj_consume_token(LEFT_PARENTHESIS);
    test = expression();
    jj_consume_token(RIGHT_PARENTHESIS);
    thenstatement = statement();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ELSE:{
      jj_consume_token(ELSE);
      elsestatement = statement();
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
{if ("" != null) return new ASTIfStatement(test, thenstatement, elsestatement, linenumbercatcher.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTEmptyStatement emptystatement() throws ParseException {Token semicolontoken; ASTEmptyStatement returnstate;
    semicolontoken = jj_consume_token(SEMICOLON);
returnstate = new ASTEmptyStatement(semicolontoken.beginLine);
{if ("" != null) return returnstate;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTDoWhileStatement dowhilestatement() throws ParseException {Token generaltoken; ASTExpression test = null; ASTStatement body;
    generaltoken = jj_consume_token(DO);
    body = statement();
    jj_consume_token(WHILE);
    jj_consume_token(LEFT_PARENTHESIS);
    test = expression();
    jj_consume_token(RIGHT_PARENTHESIS);
{if ("" != null) return new ASTDoWhileStatement(test, body, generaltoken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression initialization(ASTVariable variable) throws ParseException {ASTExpression returnval;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ADD:{
      /* {System.out.println("initialization is hit.");} */
              returnval = incrementstatement(variable);
{if ("" != null) return returnval;}
      break;
      }
    case MINUSMINUS:{
      returnval = decrementstatement(variable);
{if ("" != null) return returnval;}
      break;
      }
    case GETS:{
      returnval = assignmentstatement();
{if ("" != null) return returnval;}
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTForStatement forstatement() throws ParseException {Token fortoken;
Token identifier; ASTBaseVariable initvar; ASTExpression initexp = null; ASTAssignmentStatement init = null;
ASTExpression test = null;
Token variable; ASTBaseVariable basevar; ASTExpression incrementexp = null; ASTAssignmentStatement increment = null;
ASTStatement body;
    /*Second initialization() is actually increment from book */
            fortoken = jj_consume_token(FOR);
    jj_consume_token(LEFT_PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      identifier = jj_consume_token(IDENTIFIER);
initvar = new ASTBaseVariable(identifier.image, identifier.beginLine);
      initexp = followsvariablenames(initvar);
init = new ASTAssignmentStatement(initvar, initexp, identifier.beginLine);
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    /* test */
                    test = expression();
    jj_consume_token(SEMICOLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      variable = jj_consume_token(IDENTIFIER);
basevar = new ASTBaseVariable(variable.image, variable.beginLine);
      incrementexp = initialization(basevar);
increment = new ASTAssignmentStatement(basevar, incrementexp, variable.beginLine);
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
    body = statement();
{if ("" != null) return new ASTForStatement(init, test, increment, body, fortoken.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expression() throws ParseException {Token t;ASTExpression result; ASTExpression rhs;
    /* {System.out.println("Hit expression here.");} */
            result = expone();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
      t = jj_consume_token(OR);
      rhs = expone();
result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expone() throws ParseException {Token t; ASTExpression result; ASTExpression rhs;
    result = exptwo();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_10;
      }
      t = jj_consume_token(AND);
      rhs = exptwo();
result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression exptwo() throws ParseException {Token t = null; ASTExpression result; ASTExpression rhs;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NOT:{
      t = jj_consume_token(NOT);
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    rhs = expthree();
if (t != null) {
                result = new ASTUnaryOperatorExpression(rhs, t.image, t.beginLine);
                {if ("" != null) return result;}
        } else {
                result = rhs;
                {if ("" != null) return result;}
        }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expthree() throws ParseException {Token t; ASTExpression result; ASTExpression rhs;
    result = expfour();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUAL:
      case GREATER_THAN:
      case GREATER_THAN_OR_EQUAL_TO:
      case NOT_EQUAL:
      case LESS_THAN_OR_EQUAL_TO:
      case LESS_THAN:{
        ;
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUAL:{
        t = jj_consume_token(EQUAL);
        break;
        }
      case NOT_EQUAL:{
        t = jj_consume_token(NOT_EQUAL);
        break;
        }
      case LESS_THAN:{
        t = jj_consume_token(LESS_THAN);
        break;
        }
      case LESS_THAN_OR_EQUAL_TO:{
        t = jj_consume_token(LESS_THAN_OR_EQUAL_TO);
        break;
        }
      case GREATER_THAN:{
        t = jj_consume_token(GREATER_THAN);
        break;
        }
      case GREATER_THAN_OR_EQUAL_TO:{
        t = jj_consume_token(GREATER_THAN_OR_EQUAL_TO);
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = expfour();
result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expfour() throws ParseException {Token t; ASTExpression result; ASTExpression rhs;
    result = expfive();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        t = jj_consume_token(PLUS);
        break;
        }
      case MINUS:{
        t = jj_consume_token(MINUS);
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = expfive();
result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expfive() throws ParseException {Token t; ASTExpression result; ASTExpression rhs;
    result = F();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TIMES:
      case DIVIDE:{
        ;
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TIMES:{
        t = jj_consume_token(TIMES);
        break;
        }
      case DIVIDE:{
        t = jj_consume_token(DIVIDE);
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      rhs = F();
result = new ASTOperatorExpression(result, rhs, t.image, t.beginLine);
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression F() throws ParseException {Token t; ASTExpression value = null; ASTVariable variable = null; ASTVariableExpression variableexpression= null; ASTVariable returnvariable = null; ASTExpression functioncallexpression = null; ASTExpression incrementexpression = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:{
      jj_consume_token(MINUS);
      value = F();
{if ("" != null) return new ASTOperatorExpression(new ASTIntegerLiteral(0, 0), value, ASTOperatorExpression.MINUS, 0);}
      break;
      }
    case INTEGER_LITERAL:{
      t = jj_consume_token(INTEGER_LITERAL);
{if ("" != null) return new ASTIntegerLiteral(Integer.parseInt(t.image), t.beginLine);}
      break;
      }
    case TRUE:{
      t = jj_consume_token(TRUE);
{if ("" != null) return new ASTBooleanLiteral(Boolean.parseBoolean(t.image), t.beginLine);}
      break;
      }
    case FALSE:{
      t = jj_consume_token(FALSE);
{if ("" != null) return new ASTBooleanLiteral(Boolean.parseBoolean(t.image), t.beginLine);}
      break;
      }
    case IDENTIFIER:{
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_PARENTHESIS:{
        functioncallexpression = expressionfunctioncalls(t, t.image);
        break;
        }
      default:
        jj_la1[29] = jj_gen;
        ;
      }
if (functioncallexpression != null ) {{if ("" != null) return functioncallexpression;}}
variable = new ASTBaseVariable(t.image, t.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ADD:
      case MINUSMINUS:{
        incrementexpression = incrementstatements(variable);
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        ;
      }
if (incrementexpression != null) {{if ("" != null) return incrementexpression;}}
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:
      case IDENTIFIER:{
        variable = followsvariablenamesforexpressions(variable, t.image);
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        ;
      }
variableexpression = new ASTVariableExpression(variable, variable.line());
if (variableexpression != null) {
        {if ("" != null) return variableexpression;}
}
      break;
      }
    case NEW:{
      jj_consume_token(NEW);
      t = jj_consume_token(IDENTIFIER);
      value = followsnewandidentifier(t);
{if ("" != null) return value;}
      break;
      }
    case LEFT_PARENTHESIS:{
      jj_consume_token(LEFT_PARENTHESIS);
      value = expression();
      jj_consume_token(RIGHT_PARENTHESIS);
{if ("" != null) return value;}
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression assignmentstatement() throws ParseException {ASTExpression value;
    jj_consume_token(GETS);
    value = expression();
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression followsnewandidentifier(Token t) throws ParseException {ASTExpression returnresult = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFT_BRACKET:{
      jj_consume_token(LEFT_BRACKET);
      returnresult = followsbrackets(t);
{if ("" != null) return returnresult;}
      break;
      }
    case LEFT_PARENTHESIS:{
      jj_consume_token(LEFT_PARENTHESIS);
      jj_consume_token(RIGHT_PARENTHESIS);
{if ("" != null) return new ASTNewClassExpression(t.image, t.beginLine);}
{if ("" != null) return null;}
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression incrementstatements(ASTVariable basevar) throws ParseException {ASTAssignmentStatement assignstatement; ASTVariable variable; ASTExpression expression = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ADD:{
      /* {System.out.println("I HIT INCREMENTSTATEMENT");} */
              /*ASTAssignmentStatement(variable, ASTExpression value, int line) { */
              expression = incrementstatement(basevar);
{if ("" != null) return expression;}
      break;
      }
    case MINUSMINUS:{
      expression = decrementstatement(basevar);
{if ("" != null) return expression;}
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTVariable followsvariables(ASTVariable astvar) throws ParseException {ASTArrayVariable arrayvar; ASTExpression express; ASTClassVariable nextvariable; Token variabletoken = null; ASTVariable returnvariable = null; ASTVariable nullcase = null; ASTBaseVariable basevariable;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PERIOD:{
      jj_consume_token(PERIOD);
      variabletoken = jj_consume_token(IDENTIFIER);
nextvariable = new ASTClassVariable(astvar, variabletoken.image, variabletoken.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:{
        returnvariable = followsvariables(nextvariable);
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        ;
      }
if (returnvariable == null) {
                                {if ("" != null) return nextvariable;}
                                }
                        else {
                                {if ("" != null) return returnvariable;}
                                }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:{
        returnvariable = followsvariables(astvar);
{if ("" != null) return returnvariable;}
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        ;
      }
{if ("" != null) return nextvariable;}
      break;
      }
    case LEFT_BRACKET:{
      jj_consume_token(LEFT_BRACKET);
      express = expression();
      variabletoken = jj_consume_token(RIGHT_BRACKET);
arrayvar =  new ASTArrayVariable(astvar, express, variabletoken.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:{
        returnvariable = followsvariables(arrayvar);
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        ;
      }
if (returnvariable == null) {
                                                {if ("" != null) return arrayvar;}
                                                }
                                        else {
                                                {if ("" != null) return returnvariable;}
                                                }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:{
        returnvariable = followsvariables(astvar);
{if ("" != null) return returnvariable;}
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        ;
      }
{if ("" != null) return arrayvar;}
{if ("" != null) return nullcase;}
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression followsvariablenames(ASTVariable variable) throws ParseException {ASTExpression value = null; ASTClassVariable classvar = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GETS:{
      /* {System.out.println("I hit followsvariablenames");} */
              value = assignmentstatement();
{if ("" != null) return value;}
      break;
      }
    case ADD:
    case MINUSMINUS:{
      value = incrementstatements(variable);
{if ("" != null) return value;}
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement functioncall(Token token) throws ParseException {ASTStatement params = null;
    jj_consume_token(LEFT_PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:
    case FALSE:
    case NEW:
    case MINUS:
    case NOT:
    case LEFT_PARENTHESIS:
    case INTEGER_LITERAL:
    case IDENTIFIER:{
      params = paramslist(token.image, token);
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
functioncall = true;
                if (params != null)
                        emptyparams = false;
                {if ("" != null) return params;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement paramslist(String nameoffunction, Token variabletoken) throws ParseException {ASTExpression expressioncatch = null; ASTFunctionCallStatement funccall = new ASTFunctionCallStatement(nameoffunction, variabletoken.beginLine);
    /*public ASTFunctionCallStatement(String name, ASTExpression formal, int line) { */
            expressioncatch = expression();
if (expressioncatch != null) funccall.addElement(expressioncatch);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[42] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
      expressioncatch = expression();
if (expressioncatch != null) funccall.addElement(expressioncatch);
    }
{if ("" != null) return funccall;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionfunctioncalls(Token token, String nameoffunction) throws ParseException {ASTExpression expression; Token variabletoken; ASTFunctionCallExpression funccall; ASTExpression result = null;
    variabletoken = jj_consume_token(LEFT_PARENTHESIS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:
    case FALSE:
    case NEW:
    case MINUS:
    case NOT:
    case LEFT_PARENTHESIS:
    case INTEGER_LITERAL:
    case IDENTIFIER:{
      result = expressionlist(token.image, token);
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PARENTHESIS);
if (result == null)
                        {if ("" != null) return new ASTFunctionCallExpression(token.image, token.beginLine);}
                else
                        {if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTVariable followsvariablenamesforexpressions(ASTVariable variable, String nameoffunction) throws ParseException {ASTExpression result = null; ASTArrayVariable arrayvar = null; ASTClassVariable classvar = null; Token variabletoken; ASTBaseVariable basevar = null; ASTVariable returnvariable = null;
ASTFunctionCallExpression funccall = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      variabletoken = jj_consume_token(IDENTIFIER);
basevar = new ASTBaseVariable(variabletoken.image, variabletoken.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:
      case IDENTIFIER:{
        returnvariable = followsvariablenamesforexpressions(basevar, nameoffunction);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        ;
      }
if (returnvariable == null)
                        {if ("" != null) return basevar;}
                else
                        {if ("" != null) return returnvariable;}
      break;
      }
    case PERIOD:{
      jj_consume_token(PERIOD);
      variabletoken = jj_consume_token(IDENTIFIER);
classvar = new ASTClassVariable(variable, variabletoken.image, variabletoken.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:
      case IDENTIFIER:{
        returnvariable = followsvariablenamesforexpressions(classvar, nameoffunction);
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        ;
      }
if (returnvariable == null) {
                        {if ("" != null) return classvar;}
                        }
                else {
                        {if ("" != null) return returnvariable;}
                        }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:
      case IDENTIFIER:{
        returnvariable = followsvariablenamesforexpressions(variable, nameoffunction);
{if ("" != null) return returnvariable;}
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        ;
      }
{if ("" != null) return classvar;}
      break;
      }
    case LEFT_BRACKET:{
      jj_consume_token(LEFT_BRACKET);
      result = expression();
      variabletoken = jj_consume_token(RIGHT_BRACKET);
arrayvar = new ASTArrayVariable(variable, result, variabletoken.beginLine);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:
      case IDENTIFIER:{
        returnvariable = followsvariablenamesforexpressions(arrayvar, nameoffunction);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        ;
      }
if (returnvariable == null) {
                        {if ("" != null) return arrayvar;}
                        }
                else {
                        {if ("" != null) return returnvariable;}
                        }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:
      case PERIOD:
      case IDENTIFIER:{
        returnvariable = followsvariablenamesforexpressions(variable, nameoffunction);
{if ("" != null) return returnvariable;}
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
{if ("" != null) return arrayvar;}
      break;
      }
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//void followsbracketsone() :
//{}
//{
//	expression() <RIGHT_BRACKET> (((<LEFT_BRACKET><RIGHT_BRACKET>)))
//}
  static final public 
ASTExpression followsbrackets(Token t) throws ParseException {int counter = 0; ASTExpression value = null;
    value = expression();
    jj_consume_token(RIGHT_BRACKET);
counter++;
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT_BRACKET:{
        ;
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        break label_15;
      }
      jj_consume_token(LEFT_BRACKET);
      jj_consume_token(RIGHT_BRACKET);
counter++;
    }
{if ("" != null) return new ASTNewArrayExpression(t.image, value, counter, t.beginLine);}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public simplejavaTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[51];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x10000,0x0,0x0,0x2048f000,0x20400000,0x0,0x40000000,0x0,0x0,0x40000000,0x10960000,0x2048f000,0x0,0x0,0x0,0x2048f000,0x800,0x0,0x0,0x0,0x0,0x0,0x10000000,0xc000000,0xc000000,0xa00000,0xa00000,0x3000000,0x3000000,0x0,0x0,0x40000000,0x960000,0x40000000,0x0,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x0,0x10960000,0x0,0x10960000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x8000,0x8000,0x8000,0x0,0x2,0x0,0x8000,0x2,0x1,0xc020,0x8000,0x8000,0x3420,0x3420,0x8000,0x0,0x3400,0x8000,0x8000,0x800,0x8,0x0,0x384,0x384,0x0,0x0,0x0,0x0,0x20,0x3000,0x8001,0xc020,0x20,0x3000,0x1,0x1,0x1,0x1,0x1,0x3400,0xc020,0x2,0xc020,0x8001,0x8001,0x8001,0x8001,0x8001,0x8001,0x0,};
   }

  /** Constructor with InputStream. */
  public simplejava(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public simplejava(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new simplejavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public simplejava(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new simplejavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public simplejava(simplejavaTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(simplejavaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 51; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[48];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 51; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 48; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
